{
	parserClass="com.openc2e.plugins.intellij.caos.def.parser.CaosDefParser"
	parserUtilClass="com.openc2e.plugins.intellij.caos.def.parser.CaosDefParserUtil"
	implements="com.openc2e.plugins.intellij.caos.def.psi.api.CaosDefCompositeElement"
	extends="com.openc2e.plugins.intellij.caos.def.psi.impl.CaosDefCompositeElementImpl"
	elementTypeHolderClass="com.openc2e.plugins.intellij.caos.def.lexer.CaosDefTypes"
	elementTypePrefix="CaosDef_"
	elementTypeClass="com.openc2e.plugins.intellij.caos.def.psi.types.CaosDefElementType"
	tokenTypeClass="com.openc2e.plugins.intellij.caos.def.lexer.CaosDefTokenType"
	psiClassPrefix="CaosDef"
	psiImplClassSuffix="Impl"
	psiPackage="com.openc2e.plugins.intellij.caos.def.psi.api"
	psiImplPackage="com.openc2e.plugins.intellij.caos.def.psi.impl"
	//elementTypeFactory("")="com.openc2e.plugins.intellij.caos.def.psi.types.CaosDefElementTypeFactory.factory"
	psiImplUtilClass="com.openc2e.plugins.intellij.caos.def.parser.CaosDefParserUtil"
	tokens = [
		DOC_COMMENT_LITERAL = "regexp:/\*[*]*.*(?=[*][/])[*][/]";
		DOC_COMMENT_OPEN = 'regexp:/[*]+';
		DOC_COMMENT_CLOSE = 'regexp:[*]+/'
		LINE_COMMENT = "regexp://[^\n]*"
		EXCLUSIVE = "regexp:[!][Ee][Xx][Cc][Ll][Uu][Ss][Ii][Vv][Ee]"
		REGION_HEADING_LITERAL = "regexp:[#][^\n]+"
		WORD = "regexp:[a-zA-Z_][a-zA-Z0-9#!$_]{3}"
		ID = "regexp:[_a-zA-Z][_a-zA-Z0-9]*";
		EQ = "=";
		COMMA = ',';
		SEMI = ';'
		SINGLE_QUO = "'";
		DOUBLE_QUO = '"';
		COLON = ':';
		OPEN_PAREN = '(';
		CLOSE_PAREN = ")";
		space = "regexp:\s+";
		OPEN_BRACKET = '[';
		CLOSE_BRACKET = ']';
		OPEN_BRACE = '{';
		CLOSE_BRACE = '}';
		LEADING_ASTRISK = '*';
		DASH = '-';
		CODE_BLOCK_LITERAL = 'regexp:#\{[^}]*}';
		TYPE_LINK = 'regexp:@\{[a-zA-Z_0-9#$!]+}'
		AT_RVALUE = "regexp:[@][rR][vV][aA][lL][uU][eE]";
		AT_LVALUE = "regexp:[@][lL][vV][aA][lL][uU][eE]";
		AT_PARAM = "regexp:[@][pP][aA][rR][aA][mM]"
		AT_RETURN = "regexp:[@][rR][eE][tT][uU][rR][nN][sS]?"

		AT_ID = "regexp:[@][a-zA-Z_][a-zA-Z_0-9]";
		SINGLE_QUO_STRING = "regexp:'[^\n']*'";
		DOUBLE_QUO_STRING = 'regexp:"[^\n"]*"';
		STRING_LITERAL_TYPE
		space = "regexp:\s+"
	]
}

def	::= (!<<eof>> def_element)*
	;


def_element
	::= command_def_element end_of_statement
	|	type_definition_element
	| 	comment
	| 	NEWLINE
	| 	end_of_statement
	;


command_def_element
	::= doc_comment? command return_type arguments_list?
	{
		pin = 2;
		methods = [
			isCommand
		]
	}
	;

arguments_list
	::= variable+
	{
		recoverWhile = arguments_list_recover
	}
	;
private arguments_list_recover
	::= !(';'|NEWLINE|DOC_COMMENT_LITERAL|LINE_COMMENT)
	;


type_definition_element
	::= type_def_name type_note? type_definition_body
	{
		pin=1;
	}
	;

type_definition
	::= type_definition_key '=' type_definition_value (DASH type_definition_description)?
	{
		pin=2;
	}
	;
private type_definition_body
	::= OPEN_BRACE type_definition_list? CLOSE_BRACE
	{
		pin=1;
	}
	;

type_definition_list
	::= type_definition_statements+
	{
		//recoverWhile=type_definition_list_recover
	}
	;
private type_definition_statements
	::=	type_definition
	|	region_heading
	//|	type_def_exclusives
	;

region_heading
	::= REGION_HEADING_LITERAL
	;

private type_definition_list_recover
	::= !('}'|AT_ID)
	;

variable
	::= variable_name variable_type
	{
		pin = 2;
	}
	;

  variable_name
	::= ID
	|	WORD
	;

return_type
	::= variable_type
	{
		pin = 1
	}
	;

variable_type
	::= '(' type_literal ')'
	|	bracket_string
	;

type_literal
	::= ID
	|	WORD
	;
bracket_string
	::= '[' string_label ']'
	;

string_label
	::= (ID|WORD)+
	;

command
	::= command_word+
	;

command_word
	::= WORD
	;

type_def_name
	::= AT_ID
	;

type_definition_key
	::= TYPE_DEF_KEY
	;

type_definition_value
	::= TYPE_DEF_VALUE
	;

type_definition_description
	::= TEXT_LITERAL
	;

doc_comment
	::= DOC_COMMENT_OPEN doc_comment_body? DOC_COMMENT_CLOSE
	{
		pin=1;
	}
	;

doc_comment_body
	::= doc_comment_element+
	{
		recoverWhile=doc_comment_body_recover
	}
	;
private doc_comment_body_recover
	::= !(DOC_COMMENT_CLOSE)
	;

private doc_comment_element
	::= doc_comment_param
	|	doc_comment_return
	|	doc_comment_line
	|	rvalue
	|	lvalue
	|	LEADING_ASTRISK
	|	NEWLINE
	;

doc_comment_line
	::= doc_comment_line_items+
	;

private doc_comment_line_items
	::= code_block
	|	word_link
	|	variable_link
	|	TYPE_LINK
	|	COMMENT_TEXT_LITERAL
	|	'['
	|	WORD
	|	']'
	;

word_link
	::= '[' command ']'
	;

code_block
	::= CODE_BLOCK_LITERAL
	;

rvalue
	::= AT_RVALUE
	;
lvalue
	::= AT_LVALUE
	;

doc_comment_return
	::= AT_RETURN doc_comment_variable_type
	{
		pin=1;
	}
	;

doc_comment_param
	::= AT_PARAM variable_link doc_comment_variable_type? doc_comment_param_text? NEWLINE?
	{
		pin=1;
		//recoverWhile=doc_comment_line_recover
	}
	;

variable_link
	::= VARIABLE_LINK_LITERAL
	;

private doc_comment_line_recover
	::= !(NEWLINE|DOC_COMMENT_CLOSE)
	;

doc_comment_param_text
	::= COMMENT_TEXT_LITERAL
	;

doc_comment_variable_type
	::= '(' type_literal variable_type_tail? ')'
	|	bracket_string
	{
		pin=1;
	}
	;

private variable_type_tail
	::= type_def_name
	|	type_note
	|	variable_tail_limits
	;

type_note
	::= TYPE_NOTE_LITERAL
	;

private variable_tail_limits
	::= '[' variable_tail_prime ']'
	{
		pin=1;
	}
	;

private variable_tail_prime
	::= from_until
	|	from_to
	|	variable_length
	{
		//recoverWhile=variable_tail_prime_recover
	}
	;
private variable_tail_prime_recover
	::= !(']'|NEWLINE)
	;

variable_length
	::= INT
	{
		methods = [
			getIntValue
		]
	}
	;

from_to
	::= INT TO INT
	{
		pin=2;
		methods = [
			getIntRange
		]
	}
	;

from_until
	::= INT UNTIL INT
	{
		pin=2;
		methods = [
			getIntRange
		]
	}
	;

end_of_statement
	::= NEWLINE
	|	';'
	|	<<eos>>
	|	<<eof>>
	;

comment
	::= DOC_COMMENT_LITERAL
	|	LINE_COMMENT
	;