{
	parserClass="com.openc2e.plugins.intellij.caos.parser.CaosParser"
	implements="com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
	extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosCompositeElementImpl"
	elementTypeHolderClass="com.openc2e.plugins.intellij.caos.lexer.CaosTypes"
	elementTypePrefix="Caos_"
	elementTypeClass="com.openc2e.plugins.intellij.caos.psi.types.CaosElementType"
	tokenTypeClass="com.openc2e.plugins.intellij.caos.lexer.CaosTokenType"
	psiClassPrefix="Caos"
	psiImplClassSuffix="Impl"
	psiPackage="com.openc2e.plugins.intellij.caos.psi.api"
	psiImplPackage="com.openc2e.plugins.intellij.caos.psi.impl"
	elementTypeFactory("comment|tagLine")="com.openc2e.plugins.intellij.caos.psi.CaosElementTypeFactory.factory"
	psiImplUtilClass="com.openc2e.plugins.intellij.caos.parser.CaosParserUtil"
	tokens = [
		NEWLINE = "regexp:\n";
		ENDM = "regexp:[eE][nN][dD][mM]"
		SUBR = "regexp:[sS][uU][bB][rR]"
		GSUB = "regexp:[gG][sS][uU][bB]"
		REPS = "regexp:[rR][eE][pP][sS]"
		REPE = "regexp:[rR][eE][pP][eE]"
		LOOP = "regexp:[lL][oO][oO][pP]"
		UNTL = "regexp:[uU][nN][tT][lL]"
		EVER = "regexp:[eE][vV][eE][rR]"
		ENUM = "regexp:[eE][nN][uU][mM]"
		NEXT = "regexp:[nN][eE][xX][tT]"
		DOIF = "regexp:[dD][oO][iI][fF]"
		ELSE = "regexp:[eE][lL][sS][eE]"
		ENDI = "regexp:[eE][nN][dD][iI]"
		DOIF = "regexp:[dD][oO][iI][fF]"
		ENDI = "regexp:[eE][nN][dD][iI]"
		SCRP = "regexp:[sS][cC][rR][pP]"
		COMMENT_LITERAL = "regexp:\*[^\n]*"
		DECIMAL = "regexp:[0-9]+\.[0-9]+"
		INT = "regexp:[0-9]+"
		TEXT = 'regexp:\[[^\]]*\]';
		QUOTE_STRING = 'regexp:"[^\n|"]*"'
		ID = "regexp:[_a-zA-Z][_a-zA-Z0-9!#]*";
		COLON = ':';
		PLUS = "+";
		SPACE = "regexp:[ ]";
		TAB = "regexp:[\t]"
		OPEN_BRACKET = '[';
		CLOSE_BRACKET = ']';
		COMMA = ',';
		ANIM_R = "R"


	]
}

def	::= (!<<eof>> script_body_element)*
	;

script_body_element
	::= event_script
	|	caos_block
	{
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosBlock"
        ]
	}
	;

caos_block
	::= caos_statement+
	{
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosBlock"
        ]
	}
	;

private caos_statement
	::= whiteSpace* caos_element line_terminator
	|	whiteSpace* NEWLINE
	;

caos_element
	::= comment
	|   control_statement
	|   command
	;


event_script
	::= SCRP SPACE classifier SPACE event_number line_terminator event_script_body? whiteSpace* script_terminator
	{
		pin=1
	}
	;

private event_script_body
	::= caos_block
	{
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosBlock"
        ]
        recoverWhile=event_script_body_recover
	}
	;

private event_script_body_recover
	::= !(ENDM|SCRP|<<eof>>|<<eos>>)
	;

classifier
	::= family SPACE genus SPACE species
	;

private control_statement
    ::= loopStatement
    |   repeatStatement
    |   enumNextStatement
    |	doIfStatement
    ;


loopStatement
    ::= LOOP SPACE loop_body? line_terminator whiteSpace* loop_terminator
    {
        pin=1;
        methods = [
        	isEver
        	isUntil
        ]
    }
    ;

loop_terminator
	::= ever_terminator
	|	untl_terminator
	;

private ever_terminator
	::= EVER
	;

private untl_terminator
	::= UNTL equality_expression
	;


private loop_body
    ::= caos_block
    {
        recoverWhile=loop_body_recover
    }
    ;

private loop_body_recover
    ::= !(UNTL|EVER|ENDM)
    ;

repeatStatement
    ::= REPS SPACE expression line_terminator repeat_body? whiteSpace* REPE
    {
        pin=1
    }
    ;

repeat_body
    ::= caos_statement+
    {
        recoverWhile=repeat_body_recover
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosBlock"
        ]
    }
    ;

private repeat_body_recover
    ::= !(REPE|ENDM)
    ;

enumNextStatement
    ::= ENUM SPACE enum_header line_terminator enum_body? whiteSpace* NEXT
    {
        pin=1;
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosBlock"
        ]
    }
    ;

enum_header
    ::= expression SPACE expression SPACE expression
    {
        methods = [
            family="expression[0]"
            genus="expression[1]"
            species="expression[2]"
        ]
    }
    ;

enum_body
    ::= caos_block
    {
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosBlock"
        ]
        recoverWhile=enum_body_recover
    }
    ;

private enum_body_recover
    ::= !(NEXT|<<eof>>)
    ;


command
    ::= (namespaceToken ':' SPACE)? commandToken expressionList?
    {
        pin=2
    }
    ;

private expressionList
	::= (SPACE expression)+
	{
        recoverWhile=command_recover
	}
	;

private command_recover
	::= !(ENDM|NEWLINE)
	;

doIfStatement
	::= DOIF SPACE equality_expression line_terminator do_if_body? line_terminator (whiteSpace* else_statement)? whiteSpace* ENDI
	{
		pin=1
	}
	;

/*
else_if_statement
	::= ELIF SPACE comparisonExpression SPACE else_if_block
	{
		pin=1;
	}
	;
*/
else_statement
	::= ELSE line_terminator else_block
	{
		pin=1;
	}
	;

private else_block
	::= caos_block
	;

private do_if_body
	::= caos_block
	{
		//recoverWhile=do_if_body_recover
	}
	;

expression
    ::= equality_expression
    |   animationString
    |   expressionPrime
    ;


private expressionPrime
    ::= command
    |   literal
    |   token
    ;

equality_expression
    ::= expressionPrime eqOp expression
    ;

eqOp ::= ID;


literal
    ::= stringLiteral
    |   number
    {
        methods = [
            intValue
            isInt
            floatValue
            isFloat
            isNumeric
            stringValue
            isString
        ]
    }
    ;

number ::=INT|DECIMAL
    ;

stringLiteral
    ::= QUOTE_STRING
    |   TEXT
    {
        methods = [
            stringValue
        ]
    }
    ;

token
    ::= ID
    ;

commandToken
    ::= ID
    ;

namespaceToken
    ::= ID
    ;

comment
    ::= COMMENT_LITERAL
    {
        methods = [
            getCommentText
        ]
    }
    ;

animationString
    ::= '[' INT+ ANIM_R ']'
    ;

line_terminator
    ::= <<eof>>
    |   ","
    |   line_feed+
    ;

private line_feed
	::= comment
	|	NEWLINE
	;
script_terminator
	::= <<eos>>
	|	ENDM
	|	<<eof>>
	;

family ::= INT;
genus ::= INT;
species ::= INT;

whiteSpace
	::= NEWLINE
	|	TAB
	|	SPACE
	;

event_number
	::= INT
	;