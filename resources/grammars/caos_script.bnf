{
	parserClass="com.openc2e.plugins.intellij.caos.parser.CaosScriptParser"
	parserUtilClass="com.openc2e.plugins.intellij.caos.parser.CaosScriptParserUtil"
	implements="com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
	extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosScriptCompositeElementImpl"
	elementTypeHolderClass="com.openc2e.plugins.intellij.caos.lexer.CaosScriptTypes"
	elementTypePrefix="CaosScript_"
	elementTypeClass="com.openc2e.plugins.intellij.caos.psi.types.CaosScriptElementType"
	tokenTypeClass="com.openc2e.plugins.intellij.caos.lexer.CaosScriptTokenType"
	psiClassPrefix="CaosScript"
	psiImplClassSuffix="Impl"
	psiPackage="com.openc2e.plugins.intellij.caos.psi.api"
	psiImplPackage="com.openc2e.plugins.intellij.caos.psi.impl"
	elementTypeFactory("command|command_call|command_token|expression|var_token")="com.openc2e.plugins.intellij.caos.psi.types.CaosScriptElementTypeFactory.factory"
	psiImplUtilClass="com.openc2e.plugins.intellij.caos.psi.util.CaosScriptPsiImplUtil"
	generateTokenAccessors=true
	generateTokens=true
	name("space.*") = "space or comma"
	name("trailing_space") = ""
	tokens = [
		NEWLINE = "regexp:\n";
		ENDM = "regexp:[eE][nN][dD][mM]"
		SUBR = "regexp:[sS][uU][bB][rR]"
		REPS = "regexp:[rR][eE][pP][sS]"
		REPS = "regexp:[rR][eE][pP][sS]"
		REPE = "regexp:[rR][eE][pP][eE]"
		LOOP = "regexp:[lL][oO][oO][pP]"
		UNTL = "regexp:[uU][nN][tT][lL]"
		EVER = "regexp:[eE][vV][eE][rR]"
		ENUM = "regexp:[eE][nN][uU][mM]"
		NEXT = "regexp:[nN][eE][xX][tT]"
		DOIF = "regexp:[dD][oO][iI][fF]"
		ELSE = "regexp:[eE][lL][sS][eE]"
		ENDI = "regexp:[eE][nN][dD][iI]"
		ENDI = "regexp:[eE][nN][dD][iI]"
		SCRP = "regexp:[sS][cC][rR][pP]"
		ESCN = "regexp:[eE][sS][cC][nN]"
		NSCN = "regexp:[nN][sS][cC][nN]"
		ETCH = "regexp:[eE][tT][cC][hH]"
		ESEE = "regexp:[eE][sS][eE][eE]"
		ISCR = "regexp:[iI][sS][cC][rR]"
		VA_XX = "regexp:[Vv][Aa][0-9][0-9]"
		OB_XX = "regexp:[Oo][Vv][0-9][0-9]"
		MV_XX = "regexp:[Mm][Vv][0-9][0-9]"
		VAR_X = "regexp:[Vv][Aa][Rr][0-9]"
		OBV_X = "regexp:[Oo][Bb][Vv][0-9]"
		COMMENT_LITERAL = "regexp:\*[^\n]*"
		DECIMAL = "regexp:[0-9]+\.[0-9]+"
		INT = "regexp:[0-9]+"
		TEXT_LITERAL = 'regexp:\[[^]]*]';
		QUOTE_STRING = 'regexp:"[^\n|"]*"'
		ID = "regexp:[_a-zA-Z][_a-zA-Z0-9!#]*";
		COLON = ':';
		PLUS = "+";
		space = "regexp:[ ]";
		space = "regexp:\n[\t ]+";
		OPEN_BRACKET = '[';
		CLOSE_BRACKET = ']';
		COMMA = ',';
		AND = "AND"
		OR = "OR"
		ANIM_R = "R"
		EQ_OP_OLD_ = "EQ_OP_C1"
		EQ_OP_NEW_ = "EQ_OP_NEW"


	]
}

def	::= (script_body_element (!<<eof>> space_like_or_newline script_body_element)*  trailing_space?)?
	;

script_body_element
	::= event_script
	|	code_block space_like_or_newline script_terminator?
	{
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptHasCodeBlock"
        ]
	}
	;

code_block
	::= code_block_line (space_like_or_newline trailing_space? code_block_line)*
		{
		pin=1
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
        ]
        methods = [
        	getCodeBlock
        ]
	}
	;

code_block_line
	::= caos_element
	;

private caos_element
	::=	control_statement
	|	expression_list
	//|   command_call line_terminator
	;


event_script
	::= (SCRP|ISCR) space classifier space event_number space_like_or_newline (event_script_body space_like_or_newline)? script_terminator
	{
		pin=1
	}
	;

private event_script_body
	::= code_block
	{
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptHasCodeBlock"
        ]
        recoverWhile=event_script_body_recover
	}
	;

private event_script_body_recover
	::= !(ENDM|SCRP|<<eof>>|<<eos>>)
	;

classifier
	::= family space genus space species
	;

private control_statement
    ::= loop_statement
    |   repeat_statement
    |   enum_next_statement
    |   enum_scenery_statement
    |	doif_statement
    ;

expression_list
	::= expression (!new_line_like space_like expression)* trailing_space?
	{
		pin(".*")=1
		recoverWhile=expression_list_recover
	}

private expression_list_recover
	::= !(NEWLINE|',')
	;

loop_statement
    ::= LOOP space_like_or_newline loop_body? space_like_or_newline loop_terminator
    {
        pin=1;
        methods = [
        	isEver
        	isUntil
        ]
    }
    ;

loop_terminator
	::= ever_terminator
	|	untl_terminator
	;

private ever_terminator
	::= EVER
	;

private untl_terminator
	::= UNTL SPACE_ expression
	{
		pin=1
	}
	;


private loop_body
    ::= code_block
    {
        recoverWhile=loop_body_recover
    }
    ;

private loop_body_recover
    ::= !(UNTL|EVER|ENDM)
    ;

repeat_statement
    ::= REPS space expression space_like_or_newline (repeat_body space_like_or_newline)? REPE
    {
        pin=1
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptHasCodeBlock"
        ]

        methods = [
        ]

    }
    ;

private repeat_body
    ::= code_block
    {
        recoverWhile=repeat_body_recover
    }
    ;

private repeat_body_recover
    ::= !(REPE|ENDM)
    ;

enum_next_statement
    ::= (ENUM|ESEE|ETCH) space classifier space_like_or_newline (enum_body space_like_or_newline)? NEXT
    {
        pin=1;
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptHasCodeBlock"
        ]
        methods = [
        	codeBlock="code_block[0]"
        ]
    }
    ;

enum_scenery_statement
    ::= ESCN space classifier space_like_or_newline (enum_body space_like_or_newline)? NSCN
    {
        pin=1;
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptHasCodeBlock"
        ]
        methods = [

        ]
    }
    ;

private enum_body
    ::= code_block
    {
        implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptHasCodeBlock"
        ]
        recoverWhile=enum_body_recover
    }
    ;

private enum_body_recover
    ::= !(NEXT|<<eof>>)
    ;


/*
command_call
    ::= command expressionList?
    {
        pin=2
		stubClass="com.openc2e.plugins.intellij.caos.stubs.api.CaosScriptCommandCallStub"
		extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosScriptStubBasedElementImpl<?>"
		implements = [
            "com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
		]
		methods = [
			getCommandString
			getCommandTokens
			getParameterTypes
			getParametersLength
			getCommandTokens
			getCallType
			getPreviousCommandCalls
			consume
		]
    }
    ;


private expressionList
	::= (space expression)+
	{
        recoverWhile=command_recover
	}
	;

private command_recover
	::= !(ENDM|NEWLINE)
	;
*/
doif_statement
	::= DOIF space equality_expression space_like_or_newline (do_if_body space_like_or_newline)? (else_if space_like_or_newline)* (else_statement space_like_or_newline)? ENDI
	{
		pin=1
	}
	;


else_if
	::= ELIF space expression space_like_or_newline do_if_body?
	{
		pin=1
	}
	;

else_statement
	::= ELSE space_like_or_newline else_block
	{
		pin=1;
	}
	;

private else_block
	::= code_block
	;

private do_if_body
	::= code_block
	{
		//recoverWhile=do_if_body_recover
	}
	;

private do_if_body_recover
	::= !(ENDI|ELSE|ELIF)
	;

expression
    ::= equality_expression
    |   animation_string
    |	byte_string
    |   expression_prime
    {
    	stubClass="com.openc2e.plugins.intellij.caos.stubs.api.CaosScriptExpressionStub"
		extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosScriptStubBasedElementImpl<?>"
		implements = [
			"com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
		]
    	methods = [
    		getType
    	]
    }
    ;


private expression_prime
    ::= //command_call
       	literal
    |   var_token
    |   command_token
    ;

equality_expression
    ::= expression_prime (space expression)* space eq_op space expression (space expression)* equality_expression_plus*

    ;

equality_expression_plus
	::= (AND|OR) equality_expression
	;

eq_op
	::= eq_op_old
	|	eq_op_new
	;

eq_op_old
	::= EQ_OP_OLD_
	;

eq_op_new
	::= EQ_OP_NEW_
	;

var_token
	::= VA_XX
	| 	OV_XX
	|	OBV_X
	|	VAR_X
	|	MV_XX
	{
		stubClass="com.openc2e.plugins.intellij.caos.stubs.api.CaosScriptVarTokenStub"
		extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosScriptStubBasedElementImpl<?>"
		implements = [
			"com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
		]
		methods = [
			getVarGroup
			getVarIndex
		]
	}
	;

literal
    ::= string_literal
    |   number
    {
        methods = [
            intValue
            isInt
            floatValue
            isFloat
            isNumeric
            stringValue
            isString
        ]
    }
    ;

number
	::= INT
	|	DECIMAL
    ;

string_literal
    ::= QUOTE_STRING
    |   '[' TEXT_LITERAL ']'
    {
        methods = [
            getStringValue
        ]
    }
    ;

/*
token
    ::= ID
    ;
command
	::= command_token (space command_token)*
	{
		pin=1
		stubClass="com.openc2e.plugins.intellij.caos.stubs.api.CaosScriptCommandStub"
		extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosScriptStubBasedElementImpl<?>"
		implements = [
			"com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
		]
		methods = [
			getCommandString
			getCommandTokens
		]
	}
	;

*/
command_token
    ::= WORD
	{
		stubClass="com.openc2e.plugins.intellij.caos.stubs.api.CaosScriptCommandTokenStub"
		extends="com.openc2e.plugins.intellij.caos.psi.impl.CaosScriptStubBasedElementImpl<?>"
		implements = [
			"com.openc2e.plugins.intellij.caos.psi.api.CaosScriptCompositeElement"
			"com.openc2e.plugins.intellij.caos.psi.api.CaosScriptIsCommandToken"
		]
		methods = [
			getName
			setName
			getReference
			getIndex
			getCommandString
			isVariant
		]
	}
    ;
comment
    ::= COMMENT_LITERAL
    {
        methods = [
            getCommentText
        ]
    }
    ;

animation_string
    ::= '[' INT ANIM_R? ']'
    ;

byte_string
	::= '[' INT (space INT)* ']'
	;

new_line_like
	::= ","
	|	NEWLINE
	|	<<eof>>
	;

space_like_or_newline
	::= space_like
	|	new_line_like
	;

trailing_space
	::= space_like
	;

space_like
	::= space+
	;

private space
	::= SPACE_
	;

script_terminator
	::= ENDM
	|   <<eos>>
	|	<<eof>>
	;

family ::= INT;
genus ::= INT;
species ::= INT;

event_number
	::= INT
	;

