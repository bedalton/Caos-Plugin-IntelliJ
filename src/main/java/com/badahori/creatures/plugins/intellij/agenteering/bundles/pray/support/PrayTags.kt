package com.badahori.creatures.plugins.intellij.agenteering.bundles.pray.support

import bedalton.creatures.agents.pray.compiler.caos2pray.Caos2PrayShortTags
import com.badahori.creatures.plugins.intellij.agenteering.utils.*
import com.intellij.openapi.util.TextRange

object PrayTags {
    val tagLiterals: Map<String, Boolean> = mapOf(
        "Agent Type" to false,
        "Agent Animation File" to true,
        "Agent Sprite First Image" to false,
        "Agent Animation Gallery" to true,
        "Agent Animation String" to true,
        "Agent Bioenergy Value" to false,
        "Agent Type" to false,
        "Web Label" to true,
        "Web URL" to true,
        "Web Icon" to true,
        "Web Icon Base" to true,
        "Web Icon Animation String" to true,
        "Camera X" to false,
        "Camera Y" to false,
        "Agent Description" to true,
        "Agent Description-es" to true,
        "Agent Description-fr" to true,
        "Agent Description-it" to true,
        "Agent Description-de" to true,
        "Agent Description-nl" to true,
        "Dependency Count" to false,
        "Remove script" to true,
        "Script Count" to false
    )

    val shortTagLiterals: Map<String, Boolean> by lazy {
        Caos2PrayShortTags.SHORT_TAGS.map {
            it.key to tagLiterals[normalize(it.key)].orTrue()
        }.toMap()
    }

    val allLiterals by lazy { shortTagLiterals + tagLiterals }

    val eggTagLiterals = mapOf(
        "Genetics File" to true,
        "Egg Glyph File" to true,
        "Egg Glyph File 2" to true,
        "Egg Gallery male" to true,
        "Egg Gallery female" to true,
        "Egg Animation String" to true
    )

    val tagRegex = listOf(
        "Dependency Category \\d+".toRegex() to false,
        "Dependency \\d+".toRegex() to true,
        "Script \\d+".toRegex() to true,
    )

    private val AUTOGENERATED_TAGS = listOf(
        "Dependency\\s+Count",
        "Dependency\\s+Category\\s+\\d+",
        "Dependency\\s+\\d+",
        "Script\\s+\\d+",
        "Script\\s+Count",
        "Agent\\s+Type"
    ).joinToString("|") { "($it)" }.toRegex(RegexOption.IGNORE_CASE)



    private val SHORT_TAGS_REVERSED:Map<String,String> by lazy {
        Caos2PrayShortTags.SHORT_TAGS.map { (key, value) ->
            value to key
        }.toMap()
    }

    internal const val DEPENDENCY = 0
    internal const val DEPENDENCY_CATEGORY = 1
    internal const val SCRIPT = 2

    private val strictNumberedTagRegex = "^(?:Dependency|Dependency Category|Script) (\\d+)$".toRegex()
    private val fuzzyNumberedTagRegex =
        "^(\\s*(?:Dependency|Dependency\\s+Category|Script)\\s+)(\\d+)\\s*".toRegex(RegexOption.IGNORE_CASE)

    private val shortTags = Caos2PrayShortTags.SHORT_TAGS.keys
    private val officialTags = tagLiterals.map { it.key }
    private val officialTagsLowercase = officialTags.map { it.lowercase() to it }.toMap()

    private val eggTagLiteralsLowercased = eggTagLiterals.keys.map { it.lowercase() to it }.toMap()
    val allTags: List<String> = officialTags + shortTags
    internal const val MAX_DESCRIPTION_LENGTH = 1000

    internal val SCRIPT_TAG = "Script (\\d+)".toRegex()
    internal val DEPENDENCY_TAG = "Dependency (\\d+)".toRegex()
    internal val DEPENDENCY_CATEGORY_TAG = "Dependency Category (\\d+)".toRegex()

    internal val SCRIPT_TAG_LOWERCASE = "Script (\\d+)".toRegex(RegexOption.IGNORE_CASE)
    internal val DEPENDENCY_TAG_LOWERCASE = "Dependency (\\d+)".toRegex(RegexOption.IGNORE_CASE)
    internal val DEPENDENCY_CATEGORY_TAG_LOWERCASE = "Dependency Category (\\d+)".toRegex(RegexOption.IGNORE_CASE)

    internal val SCRIPT_TAG_FUZZY = "Script\\s+(\\d+)".toRegex(RegexOption.IGNORE_CASE)
    internal val DEPENDENCY_TAG_FUZZY = "Dependency\\s+(\\d+)".toRegex(RegexOption.IGNORE_CASE)
    internal val DEPENDENCY_CATEGORY_TAG_FUZZY = "Dependency\\s+Category\\s+(\\d+)".toRegex(RegexOption.IGNORE_CASE)

    private val allTagsFuzzy by lazy { "^("+(allTags + shortTags + eggTagLiterals.keys).joinToString("|") { "(${it.replace(WHITESPACE, "\\s+")})" } + ")$" }
    private val allTagsFuzzyRegex by lazy { allTagsFuzzy.toRegex(RegexOption.IGNORE_CASE) }

    fun isOfficialTag(tag: String, isEggs: Boolean = false): Boolean {
        return normalize(tag) != null ||
                strictNumberedTagRegex.matches(tag) ||
                (isEggs && tag in eggTagLiterals)
    }

    fun isOfficialTagFuzzy(tag: String): Boolean {
        return allTagsFuzzyRegex.matches(tag)
    }

    fun isAutogenerated(tag: String, usesRSCRCommand: Boolean): Boolean {
        if (AUTOGENERATED_TAGS.matches(tag.trim()))
            return true
        return tag.lowercase() == "remove script" && usesRSCRCommand
    }

    /**
     * Returns the matching official tag from incorrectly cased tag
     * If tag is a perfect match or no similar tag is found, null is returned
     */
    fun getCorrectedCase(tag: String): String? {
        if (tag in officialTags || strictNumberedTagRegex.matches(tag) || tag in eggTagLiterals)
            return null
        DEPENDENCY_TAG_LOWERCASE.matchEntire(tag)
            ?.groupValues
            ?.getOrNull(1)
            ?.let {
                return "Dependency $it"
            }
        DEPENDENCY_CATEGORY_TAG_LOWERCASE.matchEntire(tag)
            ?.groupValues
            ?.getOrNull(1)
            ?.let {
                return "Dependency Category $it"
            }
        SCRIPT_TAG_LOWERCASE.matchEntire(tag)
            ?.groupValues
            ?.getOrNull(1)
            ?.let {
                return "Script $it"
            }

        return officialTagsLowercase[tag.lowercase()] ?: eggTagLiteralsLowercased[tag.lowercase()]
    }


    internal fun normalize(tag: String): String? {
        if (tag in tagLiterals || strictNumberedTagRegex.matches(tag) || tag in eggTagLiterals)
            return tag
        val shortened = tag.lowercase().replace(WHITESPACE, "").trim()
        return Caos2PrayShortTags.SHORT_TAGS[shortened]
    }

    internal fun getShortTagReversed(tag: String, ignoreCase: Boolean): String? {
        SHORT_TAGS_REVERSED[tag]?.let {
            return it
        }
        if (ignoreCase) {
            SHORT_TAGS_REVERSED.keys.firstOrNull{ it.equals(tag, true) }?.let {
                return SHORT_TAGS_REVERSED[it]
            }
        }
        return null
    }

    fun getSimilarTags(tag: String, isEggs: Boolean = false, orb: Int = 5): List<String>? {
        getNumberedTagSuggestion(tag)?.let {
            return listOf(it)
        }

        val base = if (isEggs) {
            eggTagLiterals.keys
        } else
            allTags
        return base
            .map { aTag ->
                Pair(aTag, aTag.levenshteinDistance(tag))
            }.filter {
                it.second < orb
            }
            .sortedBy { it.second }
            .map { it.first }
            .nullIfEmpty()
    }


    internal fun requiresString(tag: String): Boolean? {
        return tagLiterals[tag]
            ?: eggTagLiterals[tag]
            ?: tagRegex.firstOrNull { it.first.matches(tag) }?.second
    }

    private fun getNumberedTagSuggestion(tag: String): String? {
        if (strictNumberedTagRegex.matches(tag))
            return null
        if (!fuzzyNumberedTagRegex.matches(tag))
            return null
        val parts = tag.trim().split(WHITESPACE)
        if (parts.size < 2)
            return null
        val fix = parts.joinToString(" ") { it.upperCaseFirstLetter() }
        if (fix == tag)
            return null
        return fix
    }

    fun getNumberRange(tagName: String, offset: Int): TextRange? {
        val values = fuzzyNumberedTagRegex.matchEntire(tagName)?.groupValues
            ?: return null
        val start = values.getOrNull(1)?.length
            ?: return null
        val end = values.getOrNull(2)?.length
            ?: return null
        return TextRange.create(offset + start + 1, offset + 1 + start + end)
    }


    fun getNumberedTagParts(tag: String, fuzzy: Boolean = true): Pair<Int, Int>? {
        if (fuzzy) {
            return getNumberedTagPartsFuzzy(tag)
        }
        DEPENDENCY_TAG.matchEntire(tag)
            ?.groupValues
            ?.let { groups ->
                val number = groups.getOrNull(1)?.toIntOrNull()
                    ?: return null
                return Pair(DEPENDENCY, number)
            }
        DEPENDENCY_CATEGORY_TAG.matchEntire(tag)
            ?.groupValues
            ?.let { groups ->
                val number = groups.getOrNull(1)?.toIntOrNull()
                    ?: return null
                return Pair(DEPENDENCY_CATEGORY, number)
            }
        SCRIPT_TAG.matchEntire(tag)
            ?.groupValues
            ?.let { groups ->
                val number = groups.getOrNull(1)?.toIntOrNull()
                    ?: return null
                return Pair(SCRIPT, number)
            }
        return null
    }

    private fun getNumberedTagPartsFuzzy(tag: String): Pair<Int, Int>? {
        DEPENDENCY_TAG_FUZZY.matchEntire(tag)
            ?.groupValues
            ?.let { groups ->
                val number = groups.getOrNull(1)?.toIntOrNull()
                    ?: return null
                return Pair(DEPENDENCY, number)
            }
        DEPENDENCY_CATEGORY_TAG_FUZZY.matchEntire(tag)
            ?.groupValues
            ?.let { groups ->
                val number = groups.getOrNull(1)?.toIntOrNull()
                    ?: return null
                return Pair(DEPENDENCY_CATEGORY, number)
            }
        SCRIPT_TAG_FUZZY.matchEntire(tag)
            ?.groupValues
            ?.let { groups ->
                val number = groups.getOrNull(1)?.toIntOrNull()
                    ?: return null
                return Pair(SCRIPT, number)
            }
        return null
    }


    fun getNumberedTagIndex(regex: Regex, tag: String): Int? {
        return regex
            .matchEntire(tag)
            ?.groupValues
            ?.let {
                it.lastOrNull()?.toIntOrNull()
                    ?: it.getOrNull(1)?.toIntOrNull()
            }
    }
}